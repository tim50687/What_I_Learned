# Rust

## Rust compiler

### rustc

The Rust compiler is called `rustc`. It is a command line tool that takes a Rust source file and produces a binary executable.

### cargo

The Rust package manager is called `cargo`. It is a command line tool that automates the process of building and running Rust programs.

### **Crate (Rust):**
- A crate is the smallest compilation unit in Rust.
- It contains a collection of Rust code organized into modules.
- Can be compiled into a reusable library or a standalone executable.
- Used for encapsulating and organizing code within a project.
- Acts as a building block for libraries and applications.
- No specific metadata or configuration is associated with a crate.

### **Package (Rust):**
- A package is a higher-level organizational unit in Rust.
- Consists of one or more crates.
- Defined by a `Cargo.toml` file that contains metadata and project configuration.
- Used for managing dependencies, specifying project information, and grouping related crates.
- Can include libraries, binaries, tests, and documentation.
- Cargo, the Rust package manager, manages packages and their dependencies.


## Building and running a cargo project

1. **cargo build**:
   - Command: `$ cargo build`
   - Description: This command is used to build a Rust project using Cargo.
   - Result: Cargo compiles the project and generates an executable binary in the `target/debug/` directory (or `target\debug\` on Windows) by default.
   - Note: The default build is a debug build, and Cargo puts the binary in the debug directory.

2. **Running the Executable**:
   - Command (Linux/macOS): `$ ./target/debug/hello_cargo`
   - Command (Windows): `.\target\debug\hello_cargo.exe`
   - Description: These commands are used to run the executable generated by Cargo after building the project.
   - Result: If successful, the program's output (in this case, "Hello, world!") is displayed in the terminal.

3. **cargo run**:
   - Command: `$ cargo run`
   - Description: This command compiles the code and runs the resultant executable in a single step.
   - Result: Cargo checks if the code has changed and rebuilds the project only if necessary. It then runs the executable.
   - Note: `cargo run` is a convenient way to both build and execute the code.

4. **cargo check**:
   - Command: `$ cargo check`
   - Description: This command quickly checks the code for compilation errors without producing an executable.
   - Result: Cargo checks the code and its dependencies for errors, making it faster than `cargo build`. It's useful for quickly verifying if the project compiles correctly during development.

5. **Cargo.lock**:
   - Description: Cargo creates a `Cargo.lock` file at the top level of the project. It keeps track of the exact versions of dependencies used in the project.
   - Note: Developers typically don't need to manually edit this file, as Cargo manages its contents automatically.



## **Building for Release in Rust with Cargo:**
- Command: `$ cargo build --release`
- Description: When your Rust project is ready for release, you can use this command to compile it with optimizations for performance.
- Result: This command creates an optimized executable in the `target/release` directory, rather than the `target/debug` directory used for development.
- Optimization Trade-Off: Enabling optimizations improves the runtime performance of your Rust code but increases compilation time. Therefore, two different profiles exist: one for development (fast rebuilds) and another for release (maximum performance).
- Use Case: Use `cargo build --release` when preparing the final version of your program for end-users, as it ensures the code runs as efficiently as possible.
- Benchmarking: If you're benchmarking your code's execution time, always run your benchmarks using the executable generated in the `target/release` directory to get accurate performance measurements.


## **Semantic Version Specifiers in Cargo.toml:**
- In the `[dependencies]` section of a Rust project's `Cargo.toml` file, you can specify external crate dependencies along with version requirements using Semantic Versioning (SemVer).
- Semantic Version Specifiers are used to indicate which versions of a crate your project is compatible with and which versions it should use.

**Syntax of Semantic Version Specifiers:**
- The most common specifier uses the caret (`^`) symbol, followed by a version number. For example: `^1.2.3`.
- The caret symbol indicates compatibility with any version that is at least the specified version but below the next major version.
- For `^1.2.3`, your project is compatible with any version from `1.2.3` up to, but not including, `2.0.0`.
- You can also specify a range explicitly by using a range operator. For example: `>=1.2.3, <2.0.0`.


## External Dependencies in Rust with Cargo:

**Step 1: Including an External Dependency in Cargo.toml**
- In your Rust project, you specify external dependencies by listing them in the `[dependencies]` section of your `Cargo.toml` file. You include the crate names and version requirements.

**Step 2: Running a Cargo Command**
- You run a Cargo command (e.g., `cargo build` or `cargo run`) to build or run your Rust project.

**Step 3: Updating the Registry**
- Cargo first checks if your project's dependencies are up-to-date.
- If any dependencies are not up-to-date or if this is the first time you're using a specific crate, Cargo contacts the registry (a copy of Crates.io) to ensure it has the latest information about available crates and their versions.

**Step 4: Dependency Resolution**
- Cargo performs a process called "dependency resolution" to determine the most compatible versions of the crates based on the version requirements specified in your `Cargo.toml`.
- It aims to find a combination of versions that satisfy the requirements of all your project's dependencies while avoiding version conflicts.

**Step 5: Downloading Dependencies**
- After resolving the dependencies, Cargo downloads the necessary crates and stores them in a local cache directory on your computer.
- These downloaded crates include not only the crates listed in your `[dependencies]` section but also any crates that those dependencies depend on (transitive dependencies).

**Step 6: Compiling Dependencies**
- Once Cargo has all the required crates, it compiles each of them separately. This involves generating binary code and object files for each crate.
- The compiled dependencies are now available for use by your project.

**Step 7: Compiling Your Project with Dependencies**
- Finally, Cargo compiles your Rust project, linking it with the compiled dependencies. Your project can now use the functions and types provided by these dependencies.

**Note:**
- When you include an external dependency in your Rust project, Cargo takes care of the entire process, from fetching the latest versions of crates to resolving dependencies, downloading them, and ultimately compiling both the dependencies and your project.
- This automated process simplifies managing external code and libraries in Rust projects and ensures that your project uses the correct versions of crates for a successful build and execution.


## **Reproducible Builds with the Cargo.lock File:**
- Cargo ensures that you can reproduce the same build artifact consistently by using specific versions of dependencies you've specified until you indicate otherwise.
- When you run a Cargo command, such as `cargo build`, for the first time, Cargo calculates and selects compatible versions of dependencies based on your `Cargo.toml` requirements.
- It then writes these selected versions to the `Cargo.lock` file in your project directory.
- In subsequent builds, Cargo checks for the presence of the `Cargo.lock` file. If it exists, Cargo uses the versions specified in the lock file instead of re-calculating dependencies.
- This mechanism guarantees that your project will remain at the specified dependency versions (e.g., "0.8.5" for the "rand" crate) until you explicitly update them.
- The `Cargo.lock` file is crucial for reproducible builds, ensuring that the same versions of dependencies are used consistently across different builds and environments.
- It is common practice to include the `Cargo.lock` file in your project's source control (e.g., Git) to maintain a record of the specific dependency versions used in your project, enhancing collaboration and reproducibility.


## Function

### Order
In Rust, the `order` of function definitions within the same file `does not matter` because Rust uses a two-pass compiler. Rust first scans the entire file to collect information about all functions and their signatures before generating code. As a result, you can define functions in any order within the same file, and they can reference each other without any issues.

### Assignment
In Rust, assignments do not return the value of the assignment itself. If you write `x = y = 6` in Rust, both `x` and `y` will not have the value `6`. Instead, this code will result in a compilation error because assignment in Rust is not an expression, and you cannot chain assignments like you can in some other languages.

Contrast this with languages like C and Ruby, where you can indeed write `x = y = 6`, and both `x` and `y` will have the value `6`. In those languages, assignment is an expression that returns the value being assigned, allowing you to chain assignments like this.

So, in Rust, you should use separate lines for assigning values to different variables, and assignment statements do not return the value being assigned, which differs from the behavior in languages like C and Ruby.

> A new scope block created with curly brackets is an expression

> If you add a semicolon to the end of an expression, you turn it into a statement, and it will then not return a value. Keep this in mind as you explore function return values and expressions next.

### Return Value

You can return early from a function by using the return keyword and specifying a value, but most functions return the last expression implicitly.

```rust
fn five() -> i32 {
    5
}
```
#### Example 
The error you're encountering in your Rust code is due to the presence of a semicolon (`;`) at the end of the line `x + 1;` inside the `plus_one` function. In Rust, semicolons are used to terminate statements, and they indicate that the expression has no return value, effectively returning `()` (unit type).

To fix this issue, you should remove the semicolon so that the last line of the function becomes an expression, which will be returned as the result of the function. Here's the corrected code:

```rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {x}");
}

fn plus_one(x: i32) -> i32 {
    x + 1 // Removed the semicolon here
}
```

By removing the semicolon, you allow the `x + 1` expression to be the return value of the `plus_one` function, and it will correctly return an `i32` as expected.


## Conditional Statement

- The condition in the code must be bool

In Rust, the `if` statement is an expression, which means it produces a value that can be assigned to a variable or used as part of an expression. This is a powerful feature because it allows you to conditionally assign values to variables using `if` statements in a concise and readable manner.

In the provided code:

```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {number}");
}
```

The `if` expression evaluates the condition, and if it's `true`, it returns the value `5`; otherwise, it returns the value `6`. This result is then assigned to the variable `number`. The key point here is that the type of `number` is determined by the types of the values returned by both branches of the `if` expression. In this case, `number` will have the type `i32` because both branches return integers.

Using `if` expressions in `let` statements is a clean way to conditionally set the initial value of a variable based on some condition, and it's a common pattern in Rust code.

>  the values that have the potential to be results from each arm of the if must be the same type


### Wierd 

```rust

fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;
        if counter == 10 {
            break counter * 2; // still have semi colon, but can return 
        }
    };

    println!("The result is {}", result);
}
```


## Loop

### Loop Label

In Rust, when you have nested loops, the `break` and `continue` statements by default apply to the innermost loop. However, there are situations where you might want to break out of or continue a specific outer loop, especially in complex code structures. To achieve this, you can use loop labels.

Here's how loop labels work:
- You define a loop label by placing an identifier followed by a colon (`:`) just before the `loop` keyword.
- When you use `break` or `continue`, you can specify the label to indicate which loop you want to affect.

In the provided code:

```rust
fn main() {
    let mut count = 0;
    'counting_up: loop {
        // ...

        loop {
            // ...

            if count == 2 {
                break 'counting_up; // Break out of the 'counting_up loop
            }
            // ...
        }

        count += 1;
    }
    // ...
}
```

- `'counting_up:` is a loop label for the outermost loop.
- The `break 'counting_up;` statement specifies that you want to break out of the loop labeled `'counting_up`.

In this specific example, when `count` reaches `2`, the `break 'counting_up;` statement is executed, causing the program to exit the outer loop labeled `'counting_up`. Without the label, it would break out of the innermost loop only.

Using loop labels can be helpful for maintaining code clarity and specifying exactly which loop you intend to manipulate when working with nested loops.