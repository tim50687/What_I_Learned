# Rust

## Rust compiler

### rustc

The Rust compiler is called `rustc`. It is a command line tool that takes a Rust source file and produces a binary executable.

### cargo

The Rust package manager is called `cargo`. It is a command line tool that automates the process of building and running Rust programs.

### **Crate (Rust):**
- A crate is the smallest compilation unit in Rust.
- It contains a collection of Rust code organized into modules.
- Can be compiled into a reusable library or a standalone executable.
- Used for encapsulating and organizing code within a project.
- Acts as a building block for libraries and applications.
- No specific metadata or configuration is associated with a crate.

### **Package (Rust):**
- A package is a higher-level organizational unit in Rust.
- Consists of one or more crates.
- Defined by a `Cargo.toml` file that contains metadata and project configuration.
- Used for managing dependencies, specifying project information, and grouping related crates.
- Can include libraries, binaries, tests, and documentation.
- Cargo, the Rust package manager, manages packages and their dependencies.


## Building and running a cargo project

1. **cargo build**:
   - Command: `$ cargo build`
   - Description: This command is used to build a Rust project using Cargo.
   - Result: Cargo compiles the project and generates an executable binary in the `target/debug/` directory (or `target\debug\` on Windows) by default.
   - Note: The default build is a debug build, and Cargo puts the binary in the debug directory.

2. **Running the Executable**:
   - Command (Linux/macOS): `$ ./target/debug/hello_cargo`
   - Command (Windows): `.\target\debug\hello_cargo.exe`
   - Description: These commands are used to run the executable generated by Cargo after building the project.
   - Result: If successful, the program's output (in this case, "Hello, world!") is displayed in the terminal.

3. **cargo run**:
   - Command: `$ cargo run`
   - Description: This command compiles the code and runs the resultant executable in a single step.
   - Result: Cargo checks if the code has changed and rebuilds the project only if necessary. It then runs the executable.
   - Note: `cargo run` is a convenient way to both build and execute the code.

4. **cargo check**:
   - Command: `$ cargo check`
   - Description: This command quickly checks the code for compilation errors without producing an executable.
   - Result: Cargo checks the code and its dependencies for errors, making it faster than `cargo build`. It's useful for quickly verifying if the project compiles correctly during development.

5. **Cargo.lock**:
   - Description: Cargo creates a `Cargo.lock` file at the top level of the project. It keeps track of the exact versions of dependencies used in the project.
   - Note: Developers typically don't need to manually edit this file, as Cargo manages its contents automatically.



## **Building for Release in Rust with Cargo:**
- Command: `$ cargo build --release`
- Description: When your Rust project is ready for release, you can use this command to compile it with optimizations for performance.
- Result: This command creates an optimized executable in the `target/release` directory, rather than the `target/debug` directory used for development.
- Optimization Trade-Off: Enabling optimizations improves the runtime performance of your Rust code but increases compilation time. Therefore, two different profiles exist: one for development (fast rebuilds) and another for release (maximum performance).
- Use Case: Use `cargo build --release` when preparing the final version of your program for end-users, as it ensures the code runs as efficiently as possible.
- Benchmarking: If you're benchmarking your code's execution time, always run your benchmarks using the executable generated in the `target/release` directory to get accurate performance measurements.

