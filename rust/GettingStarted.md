# Rust

## Rust compiler

### rustc

The Rust compiler is called `rustc`. It is a command line tool that takes a Rust source file and produces a binary executable.

### cargo

The Rust package manager is called `cargo`. It is a command line tool that automates the process of building and running Rust programs.

### **Crate (Rust):**
- A crate is the smallest compilation unit in Rust.
- It contains a collection of Rust code organized into modules.
- Can be compiled into a reusable library or a standalone executable.
- Used for encapsulating and organizing code within a project.
- Acts as a building block for libraries and applications.
- No specific metadata or configuration is associated with a crate.

### **Package (Rust):**
- A package is a higher-level organizational unit in Rust.
- Consists of one or more crates.
- Defined by a `Cargo.toml` file that contains metadata and project configuration.
- Used for managing dependencies, specifying project information, and grouping related crates.
- Can include libraries, binaries, tests, and documentation.
- Cargo, the Rust package manager, manages packages and their dependencies.


## Building and running a cargo project

1. **cargo build**:
   - Command: `$ cargo build`
   - Description: This command is used to build a Rust project using Cargo.
   - Result: Cargo compiles the project and generates an executable binary in the `target/debug/` directory (or `target\debug\` on Windows) by default.
   - Note: The default build is a debug build, and Cargo puts the binary in the debug directory.

2. **Running the Executable**:
   - Command (Linux/macOS): `$ ./target/debug/hello_cargo`
   - Command (Windows): `.\target\debug\hello_cargo.exe`
   - Description: These commands are used to run the executable generated by Cargo after building the project.
   - Result: If successful, the program's output (in this case, "Hello, world!") is displayed in the terminal.

3. **cargo run**:
   - Command: `$ cargo run`
   - Description: This command compiles the code and runs the resultant executable in a single step.
   - Result: Cargo checks if the code has changed and rebuilds the project only if necessary. It then runs the executable.
   - Note: `cargo run` is a convenient way to both build and execute the code.

4. **cargo check**:
   - Command: `$ cargo check`
   - Description: This command quickly checks the code for compilation errors without producing an executable.
   - Result: Cargo checks the code and its dependencies for errors, making it faster than `cargo build`. It's useful for quickly verifying if the project compiles correctly during development.

5. **Cargo.lock**:
   - Description: Cargo creates a `Cargo.lock` file at the top level of the project. It keeps track of the exact versions of dependencies used in the project.
   - Note: Developers typically don't need to manually edit this file, as Cargo manages its contents automatically.



## **Building for Release in Rust with Cargo:**
- Command: `$ cargo build --release`
- Description: When your Rust project is ready for release, you can use this command to compile it with optimizations for performance.
- Result: This command creates an optimized executable in the `target/release` directory, rather than the `target/debug` directory used for development.
- Optimization Trade-Off: Enabling optimizations improves the runtime performance of your Rust code but increases compilation time. Therefore, two different profiles exist: one for development (fast rebuilds) and another for release (maximum performance).
- Use Case: Use `cargo build --release` when preparing the final version of your program for end-users, as it ensures the code runs as efficiently as possible.
- Benchmarking: If you're benchmarking your code's execution time, always run your benchmarks using the executable generated in the `target/release` directory to get accurate performance measurements.


## **Semantic Version Specifiers in Cargo.toml:**
- In the `[dependencies]` section of a Rust project's `Cargo.toml` file, you can specify external crate dependencies along with version requirements using Semantic Versioning (SemVer).
- Semantic Version Specifiers are used to indicate which versions of a crate your project is compatible with and which versions it should use.

**Syntax of Semantic Version Specifiers:**
- The most common specifier uses the caret (`^`) symbol, followed by a version number. For example: `^1.2.3`.
- The caret symbol indicates compatibility with any version that is at least the specified version but below the next major version.
- For `^1.2.3`, your project is compatible with any version from `1.2.3` up to, but not including, `2.0.0`.
- You can also specify a range explicitly by using a range operator. For example: `>=1.2.3, <2.0.0`.


## External Dependencies in Rust with Cargo:

**Step 1: Including an External Dependency in Cargo.toml**
- In your Rust project, you specify external dependencies by listing them in the `[dependencies]` section of your `Cargo.toml` file. You include the crate names and version requirements.

**Step 2: Running a Cargo Command**
- You run a Cargo command (e.g., `cargo build` or `cargo run`) to build or run your Rust project.

**Step 3: Updating the Registry**
- Cargo first checks if your project's dependencies are up-to-date.
- If any dependencies are not up-to-date or if this is the first time you're using a specific crate, Cargo contacts the registry (a copy of Crates.io) to ensure it has the latest information about available crates and their versions.

**Step 4: Dependency Resolution**
- Cargo performs a process called "dependency resolution" to determine the most compatible versions of the crates based on the version requirements specified in your `Cargo.toml`.
- It aims to find a combination of versions that satisfy the requirements of all your project's dependencies while avoiding version conflicts.

**Step 5: Downloading Dependencies**
- After resolving the dependencies, Cargo downloads the necessary crates and stores them in a local cache directory on your computer.
- These downloaded crates include not only the crates listed in your `[dependencies]` section but also any crates that those dependencies depend on (transitive dependencies).

**Step 6: Compiling Dependencies**
- Once Cargo has all the required crates, it compiles each of them separately. This involves generating binary code and object files for each crate.
- The compiled dependencies are now available for use by your project.

**Step 7: Compiling Your Project with Dependencies**
- Finally, Cargo compiles your Rust project, linking it with the compiled dependencies. Your project can now use the functions and types provided by these dependencies.

**Note:**
- When you include an external dependency in your Rust project, Cargo takes care of the entire process, from fetching the latest versions of crates to resolving dependencies, downloading them, and ultimately compiling both the dependencies and your project.
- This automated process simplifies managing external code and libraries in Rust projects and ensures that your project uses the correct versions of crates for a successful build and execution.


## **Reproducible Builds with the Cargo.lock File:**
- Cargo ensures that you can reproduce the same build artifact consistently by using specific versions of dependencies you've specified until you indicate otherwise.
- When you run a Cargo command, such as `cargo build`, for the first time, Cargo calculates and selects compatible versions of dependencies based on your `Cargo.toml` requirements.
- It then writes these selected versions to the `Cargo.lock` file in your project directory.
- In subsequent builds, Cargo checks for the presence of the `Cargo.lock` file. If it exists, Cargo uses the versions specified in the lock file instead of re-calculating dependencies.
- This mechanism guarantees that your project will remain at the specified dependency versions (e.g., "0.8.5" for the "rand" crate) until you explicitly update them.
- The `Cargo.lock` file is crucial for reproducible builds, ensuring that the same versions of dependencies are used consistently across different builds and environments.
- It is common practice to include the `Cargo.lock` file in your project's source control (e.g., Git) to maintain a record of the specific dependency versions used in your project, enhancing collaboration and reproducibility.